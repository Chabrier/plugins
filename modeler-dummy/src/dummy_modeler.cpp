/*
 * This file is part of VLE, a framework for multi-modeling, simulation
 * and analysis of complex dynamical systems.
 * http://www.vle-project.org
 *
 * Copyright (c) 2014 INRA
 *
 */
#include <QObject>
#include <QtPlugin>
#include <QDebug>
#include "dummy_modeler.h"
#include "tabwidget.h"
#include <iostream>
#include <sstream>
#include <vle/utils/Template.hpp>

ModelerDummy::ModelerDummy() {
    mLogger    = 0;
    mSettings  = 0;
    mWidgetTab = 0;
    mWidgetEdit.clear();
    mName = "Dummy";
}

ModelerDummy::~ModelerDummy() {
    // Nothing to do ...
}

/**
 * @brief ModelerDummy::getname
 *        Return the plugin name
 */
QString ModelerDummy::getname()
{
    return mName;
}

QString ModelerDummy::getData(QString className)
{
    EditWidget *w;
    for (int i = 0; i < mWidgetEdit.count(); i++)
    {
        w = mWidgetEdit.at(i);
        if (w->getClassName() == className)
            break;
        w = 0;
    }
    if (w == 0)
        return QString();

    qDebug() << "ModelerDummy::getData() " << className;

    QString tplHead = "/**\n"                             \
            "  * @file {{classname}}.cpp\n"               \
            "  * @author Generated by DummyModeler\n"     \
            "  * \n"                                      \
            "  * @@tag Dummy@dummy_modeler @@"            \
            "class:{{classname}}@@end tag@@\n"            \
            "  */\n";
    QString tplClass = "\n"                               \
            "class {{classname}} : public ve::Dummy\n{\n" \
            "}\n" \
            "DECLARE_DYNAMICS({{namespace}}::{{classname}})\n\n";
    QString tpl = tplHead + tplClass;

    vle::utils::Template vleTpl(tpl.toStdString());
    vleTpl.stringSymbol().append("classname", className.toStdString());
    vleTpl.stringSymbol().append("namespace", "namespace_debug");

    std::ostringstream out;
    vleTpl.process(out);

    return QString( out.str().c_str() );
}

/**
 * @brief ModelerDummy::setSettings
 *        Save a pointer to the configuration file wrapper
 */
void ModelerDummy::setSettings(QSettings *s)
{
    mSettings = s;
}

/**
 * @brief ModelerDummy::setLogger
 *        Save a pointer to the logger instance of main app
 */
void ModelerDummy::setLogger(Logger *logger)
{
    mLogger = logger;
}

bool ModelerDummy::useCustomMainTab()
{
    return false;
}

/**
 * @brief ModelerDummy::getWidget
 *        Create the plugin GUI (widget inserted into main app tab)
 */
QWidget *ModelerDummy::getMainTabWidget()
{
    // If the widget has already been allocated
    if (mWidgetTab)
        // return saved pointer
        return mWidgetTab;

    // Allocate (and return) a new Simulation Tab widget
    mWidgetTab = new TabWidget();
    return mWidgetTab;
}
void ModelerDummy::delWidget()
{
    return;
}

/**
 * @brief ModelerDummy::addNewWidget
 *        Create a new tab to create and configure a new class
 */
QWidget *ModelerDummy::addNewWidget()
{
    EditWidget *newTab = new EditWidget();
    newTab->setModeNew();
    mWidgetEdit.append(newTab);

    QObject::connect(newTab, SIGNAL(nameChanged(QString)),
                     this,   SLOT  (onNameChange(QString)));
    QObject::connect(newTab, SIGNAL(saveClass()),
                     this,   SLOT  (onSaveClass()));

    return newTab;
}

/**
 * @brief ModelerDummy::addEditWidget
 *        Create a new tab to edit an existing class
 */
QWidget *ModelerDummy::addEditWidget(sourceCpp *src)
{
    EditWidget *newTab = new EditWidget();
    newTab->setModeEdit();
    mWidgetEdit.append(newTab);

    sourceCppTemplate *tpl = src->getTemplate();

    // Search the class name from tag
    newTab->setClassName( tpl->getTagValue("class") );

    return newTab;
}

void ModelerDummy::onNameChange(QString name)
{
    // Search the caller tab
    QObject *senderObject = QObject::sender();
    EditWidget *tabWidget = qobject_cast<EditWidget *>(senderObject);
    if (tabWidget == 0)
        return;

    tabWidget->setClassName(name);
    tabWidget->setModeEdit();

    // Forward this event to main app
    emit nameChanged(tabWidget, name);
}

void ModelerDummy::onSaveClass()
{
    QObject *senderObject = QObject::sender();
    EditWidget *tabWidget = qobject_cast<EditWidget *>(senderObject);
    if (tabWidget == 0)
        return;

    // Forward this event to main app
    emit saveClass(tabWidget->getClassName());
}

Q_EXPORT_PLUGIN2(modeler_dummy, ModelerDummy)
